---
title: "Exploratory Work"
author: "Youngsoo Baek"
---

```{r setup, echo=FALSE}
library(knitr)
knitr::opts_chunk$set(fig.height = 5)
airbnb <- read.csv("AB_NYC_2019.csv")
```

The `airbnb` dataset has 48,895 listings and 16 variables. We want to identify any discernible and interesting patterns among the listings in NYC. Some of the questions mentioned include:

  * What are the most influential factors on the popularity/price of the listing?
  
  * Is there heterogeneity among boroughs and neighbourhoods? If so, which of them has the highest traffic/price?
  
  * Does the type of listing vary across neighbourhoods?
  
  * What location and name are most likely to make a listing popular and/or expensive?

There are `r sum(airbnb$number_of_reviews==0)` listings (~20\%) that do not have any reviews, for which `reviews_per_month` variable is coded as missing. The number of reviews for a listing conveys its "popularity," but not the direction of the sentiment. A running assumption can be that the place will not have as many listings were it a bad one, since less people would have visited it over time due to bad reviews. 

There are also `r sum(airbnb$price==0)` listings that have prices listed as zero dollars. This can be simply a small value detection problem: prices any listing that has price below 10\$ must have been simply recorded as zero.

Ideally, we should be working towards a model that predicts popularity/price of a listing, possibly *jointly*, adjusted for its different features, including its location. Heterogeneity across neighbourhoods/boroughs can be naturally incorporated through multilevel regression. It is not yet clear how the *name* of a listing may factor into this model.

# EDA (regarding 2nd and 3rd questions)
Many listings are concentrated in Brooklyn and Manhattan, with listing prices in Manhattan being the highest on average.

```{r distn_per_borough}
library(ggplot2)
library(dplyr)
ggplot(airbnb, aes(log(price))) + geom_histogram() + facet_wrap(~ neighbourhood_group )
```

The dataset shows, as expected, an inverse relationship between popularity and price of a listing is present. Plotting the two variables on log scale reveals that variability of average price is increasing as the listings become less popular (which really means less known, since it has fewer reviews).

```{r popularity_on_price}
ggplot(airbnb, aes(number_of_reviews, price)) + geom_point() + 
           facet_wrap(~ neighbourhood_group )

ggplot(airbnb, aes(log(number_of_reviews), log(price) )) + geom_point() + 
           facet_wrap(~ neighbourhood_group )
```

On a finer scale, we are also interested in heterogeneity across neighbourhoods. There are in total `r length(unique(airbnb$neighbourhood))` distinct neighbourhoods. The following plots only show the total count of reviews and median listing prices for the 104 neighbourhoods that have more than 1,000 reviews total. 

```{r}
# Which neighbourhoods have more than 1000 reviews in total?
ns_gt_1000 <- airbnb %>% 
    group_by(neighbourhood) %>% 
    summarise(sum_reviews = sum(number_of_reviews), 
              med_price = median(price) ) %>% 
    arrange(desc(sum_reviews)) %>% filter(sum_reviews > 1000)

ggplot(ns_gt_1000) + geom_col(aes(neighbourhood, sum_reviews)) + 
    theme(axis.text.x = element_text(colour = "black", angle = 90, size = 7))

ggplot(ns_gt_1000) + geom_col(aes(neighbourhood, med_price)) + 
    theme(axis.text.x = element_text(colour = "black", angle = 90, size = 7))
```

# Is the raw count of reviews a good measure of popularity?? (Prob. not)

```{r}
airbnb %>% mutate(month = round(number_of_reviews / reviews_per_month)) %>% 
  ggplot(.) + geom_point(aes(x = number_of_reviews, reviews_per_month, col = month)) +
  scale_fill_distiller(direction = 1)
```

# Unreliability of Availability feature
The feature `availability_365` is essentially "unreliable," in the sense that its large number of zero values should be understood as a "mixture" of truly zero counts and missing values. There seem to be a significiant difference, not only between the zero group and the non-zero value group, in their average number of `reviews_per_month`, but also in the distribution. Furthermore, conditioned on the listing's belonging to the non-zero group, the predictor actually seems to have a negative correlation with monthly review rate: More available listings are only so because they were less popular to begin with! This implies the variable has a different order structure than simple integers, and adjusting for this predictor may end up leading to unreliable/variable estimates.

```{r}
airbnb_mod <- airbnb %>% mutate(aspec = as.factor(availability_365 != 0))
ggplot(airbnb_mod) + geom_histogram(aes(log(reviews_per_month), y = ..density.., 
                                        group = aspec, fill = aspec))
ggplot((airbnb %>% filter(availability_365 != 0)), aes(availability_365, log(reviews_per_month))) +
  geom_point() + 
  geom_smooth(method = "lm")
```


---------------
  
# Felt the need to revise some of the above ...

Important points.

  * There is actually **negative** correlation structure in reviews per month in distance. This makes sense given as closer the listings get (some essentially share the same coordinates), one will be sapping away potential customers of the other. Yet price still has **positive** correlation structure in distance. This implies that pricing of each listing is relatively inelastic to its popularity levels. 
  
  * Another potential issue for a spatial model, like conditional autogressive models, is that not all neighbourhoods are included in this dataset. Thus, it is possible we get "islands." Furthermore, different decisions can be made on this neighborhood structure, as the geography of NYC involves multiple little straits connected through railways and bridges.
  
```{r}
# devtools::install_github("mfherman/nycgeo")
library(sf)
library(nycgeo)
nyc_coords <- st_multipoint(as.matrix(airbnb[,c("longitude", "latitude")]))
nyc_coords_sf <- st_sfc(nyc_coords, crs = "+proj=longlat +datum=WGS84")
ggplot() + geom_sf(data = nta_sf) + geom_sf(data = nyc_coords_sf, alpha = .5) + theme_bw() 
```

  