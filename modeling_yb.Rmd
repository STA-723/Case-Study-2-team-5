---
title: "Regression Modeling"
author: "Youngsoo Baek"
date: "\\today"
---

Trying out a reasonable regression model (right now univariate, with response `price`). Ideally, we should be able to address heterogeneity in the types of listing across both neighbourhood (finer) and borough (coarser) scales. The most straightforward way to do this that I can think of is a multilevel modeling as implemented in `stanarm`. When regressing one on another, we scale the price and monthly reviews to log scale, as the dataset exhibits clear inverse relatinoship between the two.

# Before fitting

```{r prep, echo=F, include=F, message=F, warning=F}
library(dplyr)
library(ggplot2)
library(lubridate)
options(mc.cores = parallel::detectCores())
airbnb <- read.csv("./AB_NYC_2019.csv")
airbnb[airbnb$price==0, "price"] <- 5 # All imputed by 10/2
airbnb <- airbnb[airbnb$minimum_nights<=365,]

data <- airbnb[airbnb$number_of_reviews != 0,] # Exclude zero reviews
# Logarithmic scale (where rel. is actually linear)
data <- data %>% 
    mutate(price = log(price), 
           reviews_per_month = log(reviews_per_month),
           last_review = 2019 - year(ymd(last_review)),
           aspec = as.factor(availability_365!=0))
```


  i. For log transformation of price and the monthly number of reviews, here I have excluded any listings that do not have any reviews (roughly `r round(sum(airbnb$number_of_reviews==0)/nrow(airbnb) * 100, 0)`\%).
  
  ii. Housings with zero price are considerd as having a nightly price of <\$10, and imputed \$5. There are only few such listings, so the analysis should be quite insensitive to our choice of action.
  
  iii. The year in which the last review was left is included in the model as a possible predictor.
  
  iv. There are `r sum(airbnb$minimum_nights > 100)` listings that specify minimum nights of stay for more than 100 days, and among them very few have minimum nights of more than a year. I believe those listings with minimum stay of more than 365 days are likely to be measurement errors and truncate them at 365.
  
  v. After excluding listings with no reviews, there still exist `r sum(airbnb[airbnb$number_of_reviews!=0,]$availability_365==0)` listings that say they are not available in any day at all. Based on the more or less even distribution of this variable, I believe these listings simply did not choose to specify this variable. I have not yet chosen what to do with these listings, so I have simply excluded them in the model fit stage below. Imputing a single value means I am drastically changing the distribution of this underlying predictor, for which I have a strong prior belief that it is uniform.

# Fitting the  Model
All of the above steps imply that we have reduced the sample size down to `r round(nrow(data)/nrow(airbnb), 0)`\% of the original data. Still, we have a moderately large dataset for Bayesian model fitting, and computation can be difficult for even a simple multilevel model. As a preliminary step, we can quite easily fit through MLE two models, each for responses of our interest. I have excluded `availability_365` as a predictor due to multiple reasons we have discussed, plus the fact that it causes convergence failures (likely due to extreme sparsity). Instead, I have added an `aspec` feature, which is an indicator of whether a listing specified that variable or not. The justification is that listings wtih zero-valued `availability_365` variable, and thoese with non-zero values, do seem to have significant difference in the average price/popularity measures.

The estimates of our model show:

  i. **Price**: Predictors **reviews per month** and **calculated host listings** are not significant(!). Also, whatever small effects other predictors may have are dwarfed by both the heterogeneity across different neighbourhoods/boroughs, and the effect of **room type** and **aspec**. 
  
  ii. **Monthly review rate**: We already know that normal model is technically misspecified for this response. Predictors **price** and **room type** are not significant(!). Heterogeneity across neighbourhoods and boroughs are smaller relative to many of the estimated variable effects in this model. The effect of **last review date** and **aspec** again dwarf all others. 

```{r mle}
library(lme4)
# 1. Price on monthly reviews
mod1 <- lmer(price ~ 1 + reviews_per_month + room_type + minimum_nights + last_review + 
         I(last_review^2) + calculated_host_listings_count + aspec + availability_365 + 
         (1|neighbourhood_group/neighbourhood), data = data)
# 2. Monthly reviews on price
mod2 <- lmer(reviews_per_month ~ 1 + price + room_type + minimum_nights + last_review + 
         I(last_review^2) + calculated_host_listings_count + aspec + availability_365 + 
         (1|neighbourhood_group/neighbourhood), data = data)

knitr::kable(summary(mod1)$coefficients, caption = "Price: Coefficient estimates", digits = 2)
knitr::kable(as.data.frame(summary(mod1)$varcor)[,c(1,5)], 
             caption = "Price: Variance parameters", digits = 2)
knitr::kable(summary(mod2)$coefficients, caption = "Monthly review: Coefficient estiamtes", digits = 2)
knitr::kable(as.data.frame(summary(mod2)$varcor)[,c(1,5)], 
             caption = "Monthly review: Variance parameters", digits = 2)
```


# Evidence of spatial correlation
If there were some minute-scale spatial correlation between these observations unaccounted for by the model (i.e., within neighbourhood), the **semivariogram estimates** (see: https://en.wikipedia.org/wiki/Variogram) calculated from the residuals of the above model should display a clear pattern when plotted against pairwise distances. 

It is very interesting to note that there is still an evidence of spatial correlation conditional on the features. For price response, the trend of increasing semi-variogram with increasing distance is visible, though within shorter distances they seem to be more stable than the marginal semi-variograms. Even more interestingly, we see *decreasing* trend of semivariogram in increasing distance for monthly review rate response, which is rather unintuitive. This implies we have *negative* correlation structure between the monthly review rates of different listings conditioned on the model predictors (closer things repel each other).

```{r semivariogram, cache=T}
library(geoR)
empirical_vs_price <- variog(coords = data[,c("longitude", "latitude")],
                       data = resid(mod1))
empirical_vs_review <- variog(coords = data[,c("longitude", "latitude")],
                       data = resid(mod2))
par(mfrow = c(1, 2))
plot(empirical_vs_price, pch = 19, ylim = c(0, 0.6)) 
plot(empirical_vs_review, pch = 19, ylim = c(0.4, 1))
```

# Bivariate outcome regression
I want to try the following model: ordering the 1st response as price and 2nd response as monthly number of reviews (both on log-scale), we expect them to have a rather strong negative linear correlation from the EDA. A multivariate normal regression model would be:
$$
\left(\begin{array}{c}
Y_{1,i}\\ Y_{2,i} \end{array}\right) \stackrel{iid}{\sim} {\rm N}\left(
\left(\begin{array}{c}
\beta_1^T\mathbf{X}_i^T \\
\beta_2^T\mathbf{X}_i^T
\end{array}\right),
\left(\begin{array}{cc}
\sigma_1^2 & \rho\sigma_1\sigma_2\\
\rho\sigma_1\sigma_2 & \sigma_2^2
\end{array}\right)
\right),\; i=1,2,\ldots,n.
$$
We have strong prior belief that $\rho\in (-1,0)$; however, I haven't found yet a good way to make the prior distribution on the covariance to reflect this.

To facilitate model fitting procedure, I will again only let the intercepts vary between groups. Inclusion of more features will call for a Bayesian fitting with careful calibration of priors to induce shrinkage; otherwise, standard MLE will almost definitely fail to converge. 

```{r bv_lmer, cache=T}
data_for_bv <- data %>% 
  select(price, reviews_per_month, room_type, minimum_nights, last_review, 
         calculated_host_listings_count, aspec, availability_365,
         neighbourhood, neighbourhood_group)

# Hacky way to fit a multivariate response
# see https://mac-theobio.github.io/QMEE/MultivariateMixed.html, though
# I don't seem to have understood why this works either (or whether it does work)
data_for_bv_melt <- data_for_bv %>% select(price, reviews_per_month) %>% 
  reshape2::melt(.)
data_for_bv <- cbind.data.frame(data_for_bv_melt, data_for_bv[,-c(1,2)])
mod3 <- lmer(value ~ variable:(room_type + 
                                 last_review + I(last_review^2)+ 
                                 minimum_nights + 
                                 availability_365 + calculated_host_listings_count + 
                               aspec)-1 + 
               ((variable-1)|neighbourhood_group/neighbourhood),
             data = data_for_bv,
             control = lmerControl(optCtrl = list(ftol_abs = 1e-10)))
```

By jointly modeling `price` and `reviews_per_month`, we are interested in exploring the following:

  * Is the correlation between responses stronger than the correlation within neighbourhoods/boroughs?
  
  * Do the estimated effects for different factors substantially change relative to our previous model fits?

No to the second question. Depends for the first question.

```{r}
# Code to produce coefficients plot

fixed <- summary(mod3)$coefficients
fixed_price <- fixed[grepl("price", row.names(fixed)),1:2]
fixed_rev <- fixed[grepl("reviews_per_month", row.names(fixed)),1:2]
fixed_price <- cbind.data.frame(
    melt(fixed_price)[melt(fixed_price)$Var2 != "Std. Error", c("Var1", "value")], 
    lower = fixed_price[,1] - 2 * fixed_price[,2],
    upper = fixed_price[,1] + 2 * fixed_price[,2])
fixed_rev <- cbind.data.frame(
    melt(fixed_rev)[melt(fixed_rev)$Var2 != "Std. Error", c("Var1", "value")], 
    lower = fixed_rev[,1] - 2 * fixed_rev[,2],
    upper = fixed_rev[,1] + 2 * fixed_rev[,2])
#
fixed_price$Var1 <- unlist(
    lapply(
        strsplit(as.character(fixed_price$Var1), split = ":"), 
        function(x) x[2]
    )
)
#
fixed_rev$Var1 <- unlist(
    lapply(
        strsplit(as.character(fixed_rev$Var1), split = ":"), 
        function(x) x[2]
    )
)
#
g1 <- ggplot(fixed_price) + 
    geom_point(aes(x = Var1, y = value)) + 
    geom_errorbar(aes(x = Var1, ymin = lower, ymax = upper)) + 
    labs(x= "Mean +/- 2 SE", y = NULL, title = "Price") + coord_flip()

g2 <- ggplot(fixed_rev) + 
    geom_point(aes(x = Var1, y = value)) + 
    geom_errorbar(aes(x = Var1, ymin = lower, ymax = upper)) +
    labs(x= "Mean +/- 2 SE", y = NULL, title = "Monthly Reviews") + coord_flip()

ggsave(filename = "coef_price.png", plot = g1, device = "png", width = 7, height = 5, units = "in")
ggsave(filename = "coef_review.png", plot = g2, device = "png", width = 7, height = 5, units = "in")
```

